{"version":3,"file":"index.js","sources":["../src/printField.ts","../src/printMethod.ts","../src/mock.ts","../src/index.ts","../src/printEnum.ts"],"sourcesContent":["import { IType, IField, IMapField } from 'protobufjs';\nimport { OptionType } from './interface';\n\nconst TYPES: {\n  [key: string]: string;\n} = {\n  double: 'number',\n  float: 'number',\n  int32: 'number',\n  int64: 'string',\n  uint32: 'number',\n  uint64: 'string',\n  sint32: 'number',\n  sint64: 'string',\n  fixed32: 'number',\n  fixed64: 'string',\n  sfixed32: 'number',\n  sfixed64: 'string',\n  bool: 'boolean',\n  string: 'string',\n  bytes: 'string'\n};\n\nfunction getKeyType(p: Partial<IMapField>) {\n  if (p.keyType) {\n    return TYPES[p.keyType] || p.keyType;\n  }\n  return '';\n}\n\nfunction readField(\n  name: string,\n  content: {\n    [k: string]: IField;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return {\n      type: TYPES[paramValue.type] || paramValue.type,\n      keyType: getKeyType(paramValue),\n      name: paramName,\n      rule: paramValue.rule,\n      id: paramValue.id\n    };\n  });\n\n  return {\n    category: 'fields',\n    name: name,\n    params: params.sort((a, b) => a.id - b.id)\n  };\n}\n\nexport function printField(\n  name: string,\n  fieldParams: IType,\n  options: OptionType\n) {\n  const content = fieldParams.fields;\n\n  const item = readField(name, content);\n\n  const strs = item.params.map(param => {\n    if (param.rule === 'repeated') {\n      return `  ${param.name}: ${param.type}[];\\n`;\n    }\n    if (param.keyType) {\n      return `  ${param.name}: {[key: ${param.keyType}]: ${param.type}};\\n`;\n    }\n    return `  ${param.name}: ${param.type};\\n`;\n  });\n\n  // if (fieldParams.nested) {\n  //   Object.keys(fieldParams.nested).forEach(key => {\n  //     strs.push(`  ${key}: ${key};\\n`);\n  //   });\n  // }\n  const prefix = options.isDefinition ? '' : 'export ';\n\n  return `${prefix}interface ${item.name} {\\n${strs.join('')}}\\n\\n`;\n}\n","import { IService, IMethod } from 'protobufjs';\nimport { OptionType } from './interface';\n\nconst EMPTY = 'google.protobuf.Empty';\n\nfunction readMethod(\n  name: string,\n  content: {\n    [k: string]: IMethod;\n  }\n) {\n  const params = Object.keys(content).map(paramName => {\n    const paramValue = content[paramName];\n\n    return { name: paramName, ...paramValue };\n  });\n\n  return {\n    category: 'methods',\n    name: name,\n    params\n  };\n}\n\nexport function printMethod(\n  name: string,\n  methodContent: IService,\n  options: OptionType\n) {\n  const content = methodContent.methods;\n  const item = readMethod(name, content);\n\n  const strs = item.params.map(param => {\n    const requestType =\n      param.requestType === EMPTY ? '' : `params: ${param.requestType}`;\n    const responseType =\n      param.responseType === EMPTY ? '{}' : param.responseType;\n\n    const prefix = options.isDefinition ? '' : 'export ';\n    return (\n      `${prefix}interface ${param.name} {\\n` +\n      `  (${requestType}): Promise<${responseType}>;\\n` +\n      `}\\n` +\n      `\\n`\n    );\n  });\n\n  return `${strs.join('')}`;\n}\n","import protobuf, { Service, MapField, Enum, Field } from 'protobufjs';\n\nfunction _getAllMethods(root: protobuf.Root) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n\n  return firstService.methods;\n}\n\nexport function getAllMethods(source: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _getAllMethods(reflect);\n  }\n  return _getAllMethods(res.root);\n}\n\nfunction mockScalar(type: string): any {\n  switch (type) {\n    case 'string':\n      return 'Hello';\n    case 'number':\n      return 10;\n    case 'bool':\n      return true;\n    case 'int32':\n      return 10;\n    case 'int64':\n      return '20';\n    case 'uint32':\n      return 100;\n    case 'uint64':\n      return '100';\n    case 'sint32':\n      return 100;\n    case 'sint64':\n      return '-1200';\n    case 'fixed32':\n      return 1400;\n    case 'fixed64':\n      return '1500';\n    case 'sfixed32':\n      return 1600;\n    case 'sfixed64':\n      return '-1700';\n    case 'double':\n      return 1.4;\n    case 'float':\n      return 1.1;\n    case 'bytes':\n      return new Buffer('Hello');\n    default:\n      return null;\n  }\n}\n\nfunction mockType(root: protobuf.Root, typeName: string): Object {\n  const type = root.lookupTypeOrEnum(typeName);\n\n  if (type instanceof Enum) {\n    const values = Object.values(type.values);\n    return values[0];\n  }\n\n  const fieldMock =\n    type.fieldsArray &&\n    type.fieldsArray.reduce((a, b) => {\n      if (b instanceof MapField) {\n        const mockKey = mockScalar(b.keyType);\n        const mockData = mockScalar(b.type);\n        const val = mockData\n          ? { [b.name]: { [mockKey]: mockData } }\n          : { [b.name]: { [mockKey]: mockType(root, b.type) } };\n        return { ...a, ...val };\n      }\n      if (b.rule === 'repeated') {\n        const mockData = mockScalar(b.type);\n        const val = mockData\n          ? { [b.name]: [mockData] }\n          : { [b.name]: [mockType(root, b.type)] };\n        return { ...a, ...val };\n      }\n      const mockData = mockScalar(b.type);\n      const val = mockData\n        ? { [b.name]: mockData }\n        : { [b.name]: mockType(root, b.type) };\n      return { ...a, ...val };\n    }, {});\n\n  // const enumMock =\n  //   type.nestedArray &&\n  //   type.nestedArray.reduce((a, b) => {\n  //     if (b instanceof Enum) {\n  //       const values = Object.values(b.values);\n  //       if (values.length) {\n  //         const val = { [b.name]: values[0] };\n  //         return { ...a, ...val };\n  //       }\n  //       return a;\n  //     }\n  //     return a;\n  //   }, {});\n\n  return fieldMock;\n}\n\nfunction _mockResponse(root: protobuf.Root, methodName: string) {\n  const service = root.nestedArray.find(s => s instanceof Service);\n  const firstService = root.lookupService(service!.name);\n  const { responseType } = firstService.methods[methodName];\n  const res = mockType(root, responseType);\n  return res;\n}\n\nexport function mockResponse(source: string, methodName: string) {\n  const res = protobuf.parse(source, {\n    keepCase: true,\n    alternateCommentMode: true\n  });\n  if (res.package) {\n    const reflect = res.root.lookup(res.package) as protobuf.Root;\n    return _mockResponse(reflect, methodName);\n  }\n  return _mockResponse(res.root, methodName);\n}\n","import protobuf, { IService, IType, IEnum } from 'protobufjs';\nimport { printField } from './printField';\nimport { printMethod } from './printMethod';\nimport { printEnum } from './printEnum';\nimport { getAllMethods, mockResponse } from './mock';\nimport { OptionType } from './interface';\n\nconst defaultOptions: OptionType = {\n  isDefinition: true\n};\n\nexport function printTypescript(\n  json: protobuf.INamespace,\n  options: OptionType\n): string {\n  const nested = json.nested;\n  if (nested) {\n    const output = Object.keys(nested)\n      .map(name => {\n        const value = nested[name];\n\n        const res = Object.keys(value).map(category => {\n          if (category === 'fields')\n            return printField(name, value as IType, options);\n          if (category === 'methods')\n            return printMethod(name, value as IService, options);\n          if (category === 'values')\n            return printEnum(name, value as IEnum, options);\n          if (category === 'nested') return printTypescript(value, options);\n        });\n        return res;\n      })\n      .reduce((a, b) => a.concat(b), [])\n      .join('');\n\n    return output;\n  }\n  return '';\n}\n\nexport function parseProto(source: string, _options?: OptionType) {\n  const options = { ...defaultOptions, ..._options };\n  const res = protobuf.parse(source, { keepCase: true });\n  if (res.package) {\n    const root = res.root.lookup(res.package);\n    return printTypescript(root!.toJSON(), options);\n  }\n  // console.log(JSON.stringify(res.root.toJSON()));\n  return printTypescript(res.root.toJSON(), options);\n}\n\nexport { getAllMethods, mockResponse };\n\nexport default {\n  parseProto,\n  getAllMethods,\n  mockResponse\n};\n","import { IEnum } from 'protobufjs';\nimport { OptionType } from './interface';\n\nexport function printEnum(\n  name: string,\n  enumContent: IEnum,\n  options: OptionType\n) {\n  const content = enumContent.values;\n  const item = Object.keys(content)\n    .map(key => ({\n      name: key,\n      id: content[key]\n    }))\n    .sort((a, b) => a.id - b.id);\n  const strs = item.map(s => `  ${s.name} = ${s.id},\\n`).join('');\n  const prefix = options.isDefinition ? '' : 'export ';\n  return `${prefix}enum ${name} {\\n${strs}}\\n\\n`;\n}\n"],"names":["TYPES","double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes","EMPTY","getAllMethods","source","root","service","res","protobuf","parse","keepCase","alternateCommentMode","package","lookup","nestedArray","find","s","Service","lookupService","name","methods","mockScalar","type","Buffer","mockResponse","methodName","firstService","mockType","typeName","lookupTypeOrEnum","Enum","Object","values","fieldsArray","reduce","a","b","MapField","mockKey","keyType","mockData","val","rule","_mockResponse","defaultOptions","isDefinition","printTypescript","json","options","nested","keys","map","value","category","fieldParams","item","content","params","paramName","p","paramValue","id","sort","readField","fields","strs","param","join","printField","methodContent","readMethod","requestType","responseType","printMethod","enumContent","key","printEnum","concat","parseProto","_options","toJSON"],"mappings":"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"}